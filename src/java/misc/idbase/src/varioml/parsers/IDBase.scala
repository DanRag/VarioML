package varioml.parsers
import scala.util.matching.Regex
import scala.util.matching.Regex
import scala.collection.immutable.Stack
import scala.collection.immutable.{ List, HashMap }
import org.varioml.data._
import org.varioml.util._
import scala.io._
import scala.util.control.Breaks._

//need to make artificial super type for variants... because autogenerated java code do not implement inheritances
//
trait MyVariant {
  def setName(name: VariantName)
  def setTypeAttr(tpe: String)
  def getSeqChanges(): SeqChanges
  def setSeqChanges(v: SeqChanges)
  def getAliases(): Aliases
  def setAliases(v: Aliases)

}

class Feature(val seqType: String, val ref: Int) {
  var line: List[String] = List[String]()
  def add(text: String): Unit = {
    line ::= text
  }
  override def toString(): String = {
    var tmp = "[" + seqType + " " + ref + ": "
    line foreach ((line) => {
      tmp += line + " | "
    })
    return tmp + "]"
  }
}

class FeatureTable(val allele: String) {
  private var seqLevel: HashMap[Int, Feature] = new HashMap[Int, Feature]
  def leves = seqLevel
  var min: Int = 9999
  var max: Int = 0

  def add(feat: Feature): Unit = {
    seqLevel += feat.ref -> feat
    //get number range for sequence features
    if (feat.ref > max) max = feat.ref
    if (feat.ref < min) min = feat.ref
  }
  override def toString(): String = {
    var tmp: String = "[ allele " + allele + ":"
    seqLevel foreach ((tuple) => {
      tmp += tuple._2
    })
    return tmp + "]"
  }
  def get(level: Int): Feature = {
    val f = seqLevel.get(level)
    if (f.isDefined) {
      return f.get
    } else {
      return null
    }
  }
}

class RecordType(val text: String) {

  override def toString(): String = return text

}

class Record() {
  var disease: String = "";
  var propertyMap = scala.collection.mutable.Map[IDBField, RecordType]();
  var featureTables = List[FeatureTable]()

  def add(key: IDBField, text: String): Unit = {
    //append new text, if necessary. (if data is on multiple lines)
    val v = propertyMap.get(key)

    propertyMap.put(key, (if (!v.isDefined) new RecordType(text) else new RecordType(v.get + " " + text)))
  }
  def add(rec: FeatureTable): Unit = {
    featureTables ::= rec
  }

  def getFt(allele: String): FeatureTable = {
    var all = ""
    var _tmp: FeatureTable = null
    for (i <- 0 until featureTables.length; if _tmp == null) {
      if (featureTables(i).allele.equals(allele)) { _tmp = featureTables(i) }
      all += featureTables(i).allele
    }
    if ( _tmp == null) { 
    	throw new Exception("cannot get feature table for allele. Is FeatureHeader mising? " + allele + " (" + all + ")")      
    }
    return _tmp
  }

  def get(key: IDBField): String = {
    val o = propertyMap.get(key)
    if (o.isDefined) {
      return o.get.text
    }
    propertyMap foreach ((map) => {
      assert(!(map._1.name startsWith (key.name)), " found " + map._1.name)
    })

    return null
  }
}

class DataBatch {
  var header: Record = null;
  var records: List[Record] = List[Record]()
  def getHeader(f: IDBField): String = {
    var o = header.propertyMap.get(f)
    if (o.isDefined) {
      return o.get.text
    } else {
      return null
    }
  }
}

class IDBField(val name: String) {
  var regex: Regex = (name + """\s+(.+)""").r
  def setRegex(regexStr: String) {
    regex = (name + regexStr).r
  }
  override def toString(): String = {
    return name + " (Regex: " + regex + ")"
  }
}

object IDBase {
  val Database = new IDBField("Database")
  val Version = new IDBField("Version")
  val Curator = new IDBField("Curator")
  val File = new IDBField("File")
  val Phone = new IDBField("Phone")
  val Fax = new IDBField("Fax")
  val Email = new IDBField("Email")
  val URL = new IDBField("URL")
  val FTP = new IDBField("FTP")
  val Disease = new IDBField("Disease")
  val Gene = new IDBField("Gene")
  val Address = new IDBField("Address")
  val Sequence = new IDBField("Sequence")
  val Funding = new IDBField("Funding")
  val Comments = new IDBField("Comments")
  val Description = new IDBField("Description")
  val SystematicName = new IDBField("Systematic name")
  val Accession = new IDBField("Accession")
  val ID = new IDBField("ID")
  val Sex = new IDBField("Sex")
  val OMIM = new IDBField("OMIM")
  val GDB = new IDBField("GDB")
  val OriginalCode = new IDBField("Original code")
  val Date = new IDBField("Date")
  val RefNumber = new IDBField("RefNumber")
  val RefCrossRef = new IDBField("RefCrossRef")
  val RefAuthors = new IDBField("RefAuthors")
  val RefTitle = new IDBField("RefTitle")
  val RefLoc = new IDBField("RefLoc")

  val Numbering = new IDBField("Numbering")
  val EthnicOrigin = new IDBField("Ethnic origin")
  val Relative = new IDBField("Relative")
  val Diagnosis = new IDBField("Diagnosis")
  val Symptoms = new IDBField("Symptoms")
  val IDRfactfile = new IDBField("IDR factfile")
  val FeatureHeader = new IDBField("FeatureHeader"); FeatureHeader.setRegex("""\s+allele;?\s+(\d+)""")
  val Feature = new IDBField("Feature"); Feature.setRegex("""\s+(rna|dna|aa);?\s+(\d+)""")
  val FeatureElems = new IDBField("Feature"); FeatureElems.setRegex("""\s+/(.+)""")

  val EOR = new IDBField("//"); EOR.setRegex("")

  val fields = List(Database, Version, File, Curator, Address, Phone, Fax,
    Email, URL, FTP, IDRfactfile, Gene, Disease,
    OMIM, GDB, Sequence, Numbering, Funding, Comments,
    ID, Accession, SystematicName, OriginalCode, Description, Date, RefNumber, RefCrossRef,
    RefAuthors, RefTitle, RefLoc, Sex, Diagnosis, EthnicOrigin, Relative, Symptoms);

  def listToString(s: List[String]): String = {
    if (s.length == 0) return ""
    return s.head + " " + listToString(s.tail)
  }
  def handleRecord(lines: List[String]): Record = {

    val vml = new Record();
    try {
      for (i <- 0 until lines.length) {
        val line = lines(i)
        //println("LINE "+i+" "+line)

        line match {

          case FeatureHeader.regex(allele) => {
            var ft = new FeatureTable(allele)
            var j = i + 1;
            var inLoop = true
            //add all dna/rna/aa features into feature table
            while (inLoop) {
              lines(j) match {
                // mol=dna,rna,aa and num=number e.g. Feature  rna; 2
                case Feature.regex(mol, num) => {
                  var feat = new Feature(mol, num.toInt)
                  ft.add(feat)
                  var k = j + 1
                  var inLoop = true
                  //add corresponding feature elements as strings e.g. Feature /name: initiation codon
                  // string "name: initiation codon" is stored
                  while (inLoop) {
                    if (k >= lines.length) {

                      throw new Exception("Possible problem in feature table. CHECK: " + listToString(lines))

                    }
                    lines(k) match {
                      case FeatureElems.regex(text) => {
                        feat.add(text.trim())
                      }
                      case _ => {
                        assert(k > (j + 1))
                        inLoop = false
                      }
                    }
                    k += 1
                  }
                  j = k - 2
                }

                case _ => {
                  if  (j <= (i + 10)) throw new Exception("Possible problem in feature table. CHECK: " + listToString(lines))
                  ///assert(j > (i + 10)) 10 is took from hat
                  inLoop = false
                }
              }
              j += 1
            }
            vml.add(ft)
          }
          case _ => {

            // lopp over all fields (regexs) an see do they match the line 
            fields foreach ((field) => {
              //todo: optimize... now unnecessary comparisons.. chk e.g. filter or map function

              line match {

                case field.regex(text) => {
                  vml.add(field, text.trim())
                }

                case _ => {
                  //                	if ( line.startsWith("Feat")) {
                  //                	  Console.err.println("!!!!!!  Error in line" +line )
                  //                	  assert(false)
                  //                	}
                  //                }
                }
              }

            })
          }
        }

      }
    } catch {

      case x: Exception => {
        System.err.println("CANNOT PARSE ENTRY: " + x.getMessage())
      }
    }

    return vml;
  }

  def parse(source: scala.io.Source): DataBatch = {

    var lines = List[String]()
    var batch = new DataBatch();

    source.getLines.foreach((line) => {

      line match {

        case EOR.regex() => {
          val rec: Record = handleRecord(lines.reverse)
          lines = List[String]()
          if (batch.header == null) {
            batch.header = rec
          } else batch.records ::= rec
        }

        case _ => {
          lines ::= line
        }
      }

    })

    return batch
  }

  def createVariant(tpe: String, name: String): Variant = {

    val v = new Variant() with MyVariant // need to define common methods like this
    val vn = new VariantName()
    vn.setString(name)
    vn.setSchemeAttr("HGVS")
    v.setTypeAttr(tpe)
    v.setName(vn)
    return v
  }

  //sequence consequence rDNA or AA
  def createConsVariant(tpe: String, name: String): ConsVariant = {

    val v = new ConsVariant() with MyVariant // need to defined common methods
    val vn = new VariantName()
    vn.setString(name)
    vn.setSchemeAttr("HGVS")
    v.setTypeAttr(tpe)
    v.setName(vn)
    return v
  }

  def getFeatureLines(mol: String, num: Int, ft: FeatureTable): List[String] = {
    ft.leves foreach ((l) => {
      if (l._1.equals(num) && l._2.seqType.equalsIgnoreCase(mol)) {
        return l._2.line
      }
    })
    //assert( false,"feature "+mol+" "+num+" not found. Feature table="+ft)
    //return null 
    //Console.err.println("DEBUG: 	feature " + mol.toLowerCase() + " " + num + " not found. Feature table=" + ft)
    return List()
  }

  def getFeatureProperty(prop: String, mol: String, num: Int, ft: FeatureTable): String = {
    val r = (prop + ":" + """\s+(.+)""").r
    getFeatureLines(mol, num, ft) foreach ((line) => {
      line match {
        case r(text) => {
          return text
        }
        case _ =>
      }
    })
    return null
  }

  def getSomeFeatureProperty(mol: String, num: Int, ft: FeatureTable): String = {
    val r = ("\\S+:" + """\s+(.+)""").r
    getFeatureLines(mol.toLowerCase(), num, ft) foreach ((line) => {
      line match {
        case r(text) => {
          return text
        }
        case _ =>
      }
    })
    return null
  }

  def testSomeFeatureProperty(mol: String, num: Int, ft: FeatureTable) = {
    if (getSomeFeatureProperty(mol, num, ft) == null) {
      throw new Exception("No features found for " + mol.toLowerCase() + "; " + num + " feture table=" + ft)
    }
  }

  /* get locations from feature table */
  def getLocations(mol: String, num: Int, ft: FeatureTable): List[(String, (Int, Int))] = {
    var locations = List[(String, (Int, Int))]()
    val loc = getFeatureProperty("loc", mol.toLowerCase(), num, ft)
    //assert( loc != null, "Cannot find location entry for: " +mol+" "+num)
    if (loc == null) {
      return null
    }
    val acc = loc split """\s*;\s*"""
    val IntRange = """([\S^:]+):\s+(\d+)\.+(\d+)\s*""".r;
    val IntStart = """([\S^:]+):\s+(\d+)\s*""".r;
    val DbIntRange = """([\S^:]+):\s+([\S^:]+):\s+(\d+)\.+(\d+)\s*""".r;
    val DbIntStart = """([\S^:]+):\s+([\S^:]+):\s+(\d+)\s*""".r;
    val DbAcc = """([\S^:]+):\s*([\S^:]+)\s*""".r;

    var _start: Int = -1;
    var _end: Int = -1;
    acc.reverse foreach ((a) => {
      a match {
        case IntRange(acc, start, end) => {
          assert(_start == -1)
          _start = start.toInt
          _end = end.toInt
          locations ::= (acc, (_start, _end))
        }
        case IntStart(acc, start) => {
          assert(_start == -1)
          _start = start.toInt
          _end = start.toInt
          locations ::= (acc, (_start, _end))

        }
        case DbIntRange(db, acc, start, end) => {
          assert(_start == -1)
          _start = start.toInt
          _end = end.toInt
          locations ::= (db + ":" + acc, (_start, _end))

        }
        case DbIntStart(db, acc, start) => {
          assert(_start == -1)
          _start = start.toInt
          _end = start.toInt
          locations ::= (db + ":" + acc, (_start, _end))
        }
        case DbAcc(db, acc) => {
          assert(_start > -1)
          locations ::= (db + ":" + acc, (_start, _end))
        }
        case _ => {
          assert(false, "unknown location entry: " + a)
        }

      }
    })
    return locations
  }

  //parse systematic name. Return list of HGVS names or null if not OK
  def parseSysName(text: String): Array[String] = {

    var txt = text.replaceAll("\\s+", " ").replace("\\s$", "").replace(",", "")
    var names = txt.split("\\s+") filter ((v) => v.length() > 0)
    assert(names.length != 0, " Unknown sys name " + text)
    var error = false
    names foreach ((n) => {
      if (!n.matches("[gcrp]\\.\\S+")) {
        Console.err.println("DEBUG: Error in name  " + n + ". Text was " + text)
        error = true
      }
    })

    if (error) {
      return null //error case todo: throw exception?
    } else {
      return names
    }

  }

  //todo: merge createVariant and creteConsVariant methods
  def createVariant(typeAttr: String, name: String, counter: Int, ft: FeatureTable): MyVariant = {
    val v = {
      if (typeAttr.equals("DNA")) { new Variant() with MyVariant }
      else { new ConsVariant() with MyVariant }
    }

    val n = new VariantName(name)
    n.setSchemeAttr("HGVS")
    v.setName(n)
    v.setTypeAttr(typeAttr)
    if (typeAttr.equalsIgnoreCase("dna") ||
      typeAttr.equalsIgnoreCase("rna") ||
      typeAttr.equalsIgnoreCase("aa")) {
      val locs = getSomeFeatureProperty(typeAttr, counter, ft)
      if (locs == null) {
        throw new Exception("feature table probably not OK or counter is out of sync.. No entries found for: " + typeAttr.toLowerCase() + " " + counter + "; Feature table=" + ft)
      }
    }
    return v
  }

  def getSeqChanges(variant: MyVariant): SeqChanges = {

    if (variant.getSeqChanges() == null) {
      variant.setSeqChanges(new SeqChanges())
    }
    return variant.getSeqChanges()
  }
  def getAliases(variant: MyVariant): Aliases = {

    if (variant.getAliases() == null) {
      variant.setAliases(new Aliases())
    }
    return variant.getAliases()
  }

  //dig out genomic variants and corresponding sequence consequences (resulting RNAs and AAs) with their feature details
  def getGenomicVariants(sysNames: Array[String], ft: FeatureTable, counterStart: Int): (List[Variant], Int) = {

    assert(counterStart >= 0, "counter " + counterStart)
    assert(sysNames.length > 0)

    val Dna = """^g\..+""".r
    val cDna = """^c\..+""".r
    val rDna = """^r\..+""".r
    val AA = """^p\..+""".r

    var variantList: List[Variant] = List[Variant]()
    var cDNAvariantList: List[Variant] = List[Variant]()
    var RNAvariantList: List[ConsVariant] = List[ConsVariant]()
    var AAvariantList: List[ConsVariant] = List[ConsVariant]()

    var isFeatureTableOK = true

    //testing
    var rnaMissing = true

    sysNames foreach ((s) => {

      val name = new VariantName(s)
      name.setSchemeAttr("HGVS")
      s match {

        case Dna() => {

          val v = createVariant("DNA", s)
          variantList ::= v

        }

        case cDna() => {

          val v = createVariant("cDNA", s)
          cDNAvariantList ::= v

        }

        case rDna() => {

          val v = createConsVariant("RNA", s)
          RNAvariantList ::= v

        }

        case AA() => {

          val v = createConsVariant("AA", s)
          AAvariantList ::= v

        }

        case _ => {
          sysNames foreach ((name) => { println(name) })
          assert(false, "Unknown name=" + s)

        }
      }
    })

    var counter = counterStart //counter used to get feature table entries like Feature  dna; 1

    //we need to figure how DNA, RNA ja AA sequence are related
    if (variantList.length == RNAvariantList.length &&
      variantList.length == AAvariantList.length) {

      // no problem with this..
      //val chk = getSomeFeatureProperty(typeAttr, counter, ft)

      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        val rna = RNAvariantList(i)
        val aa = AAvariantList(i)
        counter += 1
        val dnaFT = testSomeFeatureProperty("DNA", counter, ft)
        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft)
        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft)
        getSeqChanges(dna.asInstanceOf[MyVariant]).addVariant(rna)
        getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)

      }
      counter = variantList.length * 3;

    } else if (RNAvariantList.length == 0 && // no RNAs in systematicName field
      variantList.length == AAvariantList.length) {

      // we could create dummy RNAss but not done right now
      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        //val rna = RNAvariantList(i)
        val aa = AAvariantList(i)
        counter += 1
        val dnaFT = testSomeFeatureProperty("DNA", counter, ft)
        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft) // we should have feature table data for RNAs there anyway
        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft)
        getSeqChanges(dna.asInstanceOf[MyVariant]).addVariant(aa) // AA added directly into DNA variant
        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)

      }
      counter = variantList.length * 3; // we need to increment like this

    } else if (variantList.length == RNAvariantList.length &&
      AAvariantList.length == 0) {

      // we could create dummy AAs but not done right now
      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        val rna = RNAvariantList(i)
        //val aa = AAvariantList(i)
        counter += 1
        val dnaFT = testSomeFeatureProperty("DNA", counter, ft)
        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft)
        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft) // aa data should be there still??...check
        getSeqChanges(dna.asInstanceOf[MyVariant]).addVariant(rna)
        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)

      }
      counter = variantList.length * 3; // we need to increment like this      

    } else if (variantList.length > 0 &&
      RNAvariantList.length == 0 && AAvariantList.length == 0) {

      // we could create dummy AA and RNAss but not done right now
      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        //val rna = RNAvariantList(i)
        //val aa = AAvariantList(i)
        counter += 1
        val dnaFT = testSomeFeatureProperty("DNA", counter, ft)
        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft) // rna data should be there still ...
        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft) // aa data should be there still??...check
        //getSeqChanges(dna.asInstanceOf[MyVariant]).addVariant(rna)
        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)

      }
      counter = variantList.length * 3; // we need to increment like this      

    } else {

      throw new Exception("Do not undestand how systematic names are grouped.. i.e. how DNA - RNA - AA are related and how they match feature table entries")

    }

    return (variantList, counter)
  }

  def toXML(batch: DataBatch): CafeVariome = {

    val lsdb = new CafeVariome()
    val source = new org.varioml.data.Source()
    val contact = new Contact()
    contact.setName(batch.getHeader(Curator))
    contact.setAddress(batch.getHeader(Address))
    source.setName(batch.getHeader(Database))
    source.addContact(contact)
    var ack = new Acknowledgement()
    ack.setName(batch.getHeader(Funding))
    source.addAcknowledgement(ack)

    lsdb.addSource(source)

    var counter = 0
    var failed = 0
    var noSystematicName = 0

    batch.records foreach ((rec) => {

      try {
        counter += 1
        val inv = new Individual()
        val panel = new Panel()
        panel.addIndividual(inv)
        inv.setIdAttr(rec.get(Accession))
        val pheno = new Phenotype()
        pheno.setTermAttr(rec.get(Disease)) //NOTE THIS IS FENOTYPE TESTED.. 
        panel.addPhenotype(pheno)
        if (rec.get(OMIM) != null) {
          pheno.setAccessionAttr(rec.get(OMIM))
          pheno.setSourceAttr("OMIM")
        }
        val symptoms = rec.get(Symptoms)
        if (symptoms != null) {
          symptoms.split(";") foreach ((s) => {
            val comment = new Comment()
            comment.setTermAttr("symptom")
            val text = new CommentText()
            text.setString(s.trim)
            comment.addText(text)
            pheno.addComment(comment)
          })

        }

        val sysName = rec.get(SystematicName)
        //get systematic names and try to find corresonding feature table entry
        // like: Feature         dna; 1
        if (sysName != null) {

          var allelesStr: String = null
          //handle different sname entries
          val case1 = "Allele\\s+1\\s+and\\s+Allele\\s+2:?\\s+(\\S+.*)".r
          val case2 = "Allele\\s+1\\s+and\\s+2:?\\s+(\\S+.*)".r
          val case3 = "Allele\\s+1:?\\s+(\\S+.*)".r
          val case4 = "\\s*(\\S+.*)".r

          var homozygVariant = false
          var genotypeVariant = false
          val EMPTY_ARRAY = Array("")
          var systematicNames = (EMPTY_ARRAY, EMPTY_ARRAY)

          sysName match {
            case case1(text) => {
              val names = parseSysName(text)
              systematicNames = (names, names)
              homozygVariant = true
            }
            case case2(text) => {

              val names = parseSysName(text)
              systematicNames = (names, names)
              homozygVariant = true
            }
            case case3(_text) => {

              var text = _text.replaceAll("Allele 1:?", "") // we may have other Allele 1s there see adabase.dat A0057
              if (text.indexOf("Allele 2") > -1) {

                val texts = text split "Allele 2:?"
                if( texts.length != 2) {
                   throw new Exception("Systematic name is not as it should be: "+_text)
                }

                val names1 = parseSysName(texts.head)
                val names2 = parseSysName(texts.tail.head)
                systematicNames = (names1, names2)
                genotypeVariant = true

              } else {

                val names = parseSysName(text)
                systematicNames = (names, names)
                homozygVariant = false

              }
            }
            case case4(text) => {
              if ( text.indexOf("Allele") > -1) {
            	  throw new Exception("Unknown systematic name " + sysName + " " + inv.getIdAttr())                
              }
              val names = parseSysName(text)
              systematicNames = (names, names)
              homozygVariant = false
            }

            case _ => {
              throw new Exception("Unknown systematic name " + sysName + " " + inv.getIdAttr())
            }
          }

          val vari = {

            if (systematicNames._1 != null && systematicNames._2 != null) {

              try {
                val v = new Variant()

                val hap1 = new Haplotype()
                val (v1, c) = getGenomicVariants(systematicNames._1, rec.getFt("1"), 0)
                v1 foreach ((va) => {
                  hap1.addVariant(va)
                })

                if (!homozygVariant) {
                  val (v2, c2) = getGenomicVariants(systematicNames._2, rec.getFt("2"), c)
                  val hap2 = new Haplotype()
                  v2 foreach ((va) => {
                    hap2.addVariant(va)
                  })
                }

                v.setGenotypicAttr(true)

                v
              } catch {

                //todo: move exception handling out
                case x: Exception => {
                  throw new Exception(" CHECK PATIENT=" + inv.getIdAttr() + " " + x.getMessage())
                }

              }

            } else {

              throw new Exception(" CHECK PATIENT=" + inv.getIdAttr() + ". Cannot parse systematic name: " + sysName + " " + systematicNames._1)
              return null

            }

          }

          vari.addPanel(panel)
          lsdb.addVariant(vari)

        } else {

          noSystematicName += 1

        }
      } catch {

        case x: Exception => {

          System.err.println(x.getMessage())
          failed += 1
        }

      }

    }) // looping over records

    println("Individuals " + counter + " ft failed =" + failed + " no systematic name=" + noSystematicName)

    XMLUtil.write(lsdb, "tmp.xml")
    return lsdb
  }

  def processFile(file: java.io.File) = {
    val s = scala.io.Source.fromFile(file)
    val batch = parse(s)

    toXML(batch)
    batch.header.propertyMap foreach ((tuple) => {
      //println(tuple._1 + " Value= " + tuple._2)
    })
    batch.records.foreach((rec) => {
      rec.featureTables foreach ((ft) => {
        //println(ft)
      })
    })
  }

  def main(args: Array[String]) {
    assert(args.length > 0)

    val file = args(0);
    println("File: " + file)

    val f = new java.io.File(file)
    if (f.isDirectory()) {

      val files = f.listFiles()
      (files filter (f => """.*\.dat$""".r.findFirstIn(f.getName).isDefined)) foreach ((_file) => {
        if (_file != null && _file.canRead()) {

          println("Reading " + _file.getPath())
          processFile(_file)

        } else {

          Console.err.println("Cannot read file " + _file.getPath())
        }
      })

    } else {

      processFile(new java.io.File(file))
    }

  }
}