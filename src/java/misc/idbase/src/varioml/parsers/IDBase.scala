package varioml.parsers
import scala.util.matching.Regex
import scala.util.matching.Regex
import scala.collection.immutable.Stack
import scala.collection.immutable.{ List, HashMap }
import org.varioml.jaxb._
import org.varioml.util._
import scala.io._
import scala.util.control.Breaks._
import scala.collection.JavaConversions._
import java.io.File

////need to make artificial super type for variants... because autogenerated java code do not implement the inheritance
////
//trait MyVariant {
//  def setName(name: VariantName)
//  def getTypeAttr(): String
//  def setRefSeq(ref: RefSeq)
//  def getRefSeq(): RefSeq
//  def setTypeAttr(tpe: String)
//  def getSeqChanges(): SeqChanges
//  def setSeqChanges(v: SeqChanges)
//  def getAliases(): Aliases
//  def setAliases(v: Aliases)
//  def addLocation(l: Location)
//  def addComment(text: Comment)
//}

class Feature(val seqType: String, val ref: Int) {
  var line: List[String] = List[String]()

  def add(text: String): Unit = {
    line :+= text
  }
  override def toString(): String = {
    var tmp = "[" + seqType + " " + ref + ": "
    line foreach ((line) => {
      tmp += line + " | "
    })
    return tmp + "]"
  }
}

class FeatureTable(val allele: String) {
  private var seqLevel: HashMap[Int, Feature] = new HashMap[Int, Feature]
  def leves = seqLevel
  var min: Int = 9999
  var max: Int = 0

  def add(feat: Feature): Unit = {
    seqLevel += feat.ref -> feat
    //get number range for sequence features
    if (feat.ref > max) max = feat.ref
    if (feat.ref < min) min = feat.ref
  }
  override def toString(): String = {
    var tmp: String = "[ allele " + allele + ":"
    seqLevel foreach ((tuple) => {
      tmp += tuple._2
    })
    return tmp + "]"
  }
  def get(level: Int): Feature = {
    val f = seqLevel.get(level)
    if (f.isDefined) {
      return f.get
    } else {
      return null
    }
  }
}

class RecordType(val text: String) {

  override def toString(): String = return text

}

class Record() {
  var disease: String = "";
  var propertyMap = scala.collection.mutable.Map[IDBField, RecordType]();
  var featureTables = List[FeatureTable]()

  def add(key: IDBField, text: String): Unit = {
    //append new text, if necessary. (if data is on multiple lines)
    val v = propertyMap.get(key)

    propertyMap.put(key, (if (!v.isDefined) new RecordType(text) else new RecordType(v.get + " " + text)))
  }
  def add(rec: FeatureTable): Unit = {
    featureTables :+= rec
  }

  def getFt(allele: String): FeatureTable = {
    var all = ""
    var _tmp: FeatureTable = null
    for (i <- 0 until featureTables.length; if _tmp == null) {
      if (featureTables(i).allele.equals(allele)) { _tmp = featureTables(i) }
      all += featureTables(i)
    }
    if (_tmp == null) {
      throw new Exception("cannot get feature table for allele. " + allele + " Is FeatureHeader mising?  FeatureTable=" + all)
    }
    return _tmp
  }

  def get(key: IDBField): String = {
    val o = propertyMap.get(key)
    if (o.isDefined) {
      return o.get.text
    }
    propertyMap foreach ((map) => {
      assert(!(map._1.name startsWith (key.name)), " found " + map._1.name)
    })

    return null
  }
}

class DataBatch {
  var header: Record = null;
  var records: List[Record] = List[Record]()
  def getHeader(f: IDBField): String = {
    var o = header.propertyMap.get(f)
    if (o.isDefined) {
      return o.get.text
    } else {
      return null
    }
  }
}

class IDBField(val name: String) {
  var regex: Regex = (name + """\s+(.+)""").r
  def setRegex(regexStr: String) {
    regex = (name + regexStr).r
  }
  override def toString(): String = {
    return name + " (Regex: " + regex + ")"
  }
}

object IDBase {
  val Database = new IDBField("Database")
  val Version = new IDBField("Version")
  val Curator = new IDBField("Curator")
  val File = new IDBField("File")
  val Phone = new IDBField("Phone")
  val Fax = new IDBField("Fax")
  val Email = new IDBField("Email")
  val URL = new IDBField("URL")
  val FTP = new IDBField("FTP")
  val Disease = new IDBField("Disease")
  val Gene = new IDBField("Gene")
  val Address = new IDBField("Address")
  val Sequence = new IDBField("Sequence")
  val Funding = new IDBField("Funding")
  val Comments = new IDBField("Comments")
  val Description = new IDBField("Description")
  val SystematicName = new IDBField("Systematic name")
  val Accession = new IDBField("Accession")
  val ID = new IDBField("ID")
  val Sex = new IDBField("Sex")
  val OMIM = new IDBField("OMIM")
  val GDB = new IDBField("GDB")
  val OriginalCode = new IDBField("Original code")
  val Date = new IDBField("Date")
  val RefNumber = new IDBField("RefNumber")
  val RefCrossRef = new IDBField("RefCrossRef")
  val RefAuthors = new IDBField("RefAuthors")
  val RefTitle = new IDBField("RefTitle")
  val RefLoc = new IDBField("RefLoc")

  val Numbering = new IDBField("Numbering")
  val EthnicOrigin = new IDBField("Ethnic origin")
  val Relative = new IDBField("Relative")
  val Diagnosis = new IDBField("Diagnosis")
  val Symptoms = new IDBField("Symptoms")
  val IDRfactfile = new IDBField("IDR factfile")
  val FeatureHeader = new IDBField("FeatureHeader"); FeatureHeader.setRegex("""\s+allele;?\s+(\d+)""")
  val Feature = new IDBField("Feature"); Feature.setRegex("""\s+(rna|dna|aa);?\s+(\d+)""")
  val FeatureElems = new IDBField("Feature"); FeatureElems.setRegex("""\s+/(.+)""")

  val EOR = new IDBField("//"); EOR.setRegex("")

  val fields = List(Database, Version, File, Curator, Address, Phone, Fax,
    Email, URL, FTP, IDRfactfile, Gene, Disease,
    OMIM, GDB, Sequence, Numbering, Funding, Comments,
    ID, Accession, SystematicName, OriginalCode, Description, Date, RefNumber, RefCrossRef,
    RefAuthors, RefTitle, RefLoc, Sex, Diagnosis, EthnicOrigin, Relative, Symptoms);

  def listToString(s: List[String]): String = {
    if (s.length == 0) return ""
    return s.head + " " + listToString(s.tail)
  }
  def handleRecord(aLines: List[String]): Record = {

    var lines = List[String]()
    var fixed = ""
    for (i <- 0 until aLines.length) {
      if (aLines(i).matches("^Feature\\s+dna;\\s+1\\s*")) {
        if (!aLines(i - 1).matches("^FeatureHeader.+")) {
          fixed = "FIXED"
          lines :+= "FeatureHeader   allele; 1"
        }
      }
      lines :+= aLines(i)
    }

    val vml = new Record();
    try {
      for (i <- 0 until lines.length) {
        val line = lines(i)
        //println("LINE "+i+" "+line)

        line match {

          case FeatureHeader.regex(allele) => {
            var ft = new FeatureTable(allele)

            var j = i + 1;
            var inLoop = j < lines.length && !lines(j).equals(EOR.regex)

            //assert(fixed.equals(""),"CHK "+fixed )
            //add all dna/rna/aa features into feature table
            while (inLoop) {
              //System.err.println("DEBUG "+lines(j) )
              lines(j) match {
                // mol=dna,rna,aa and num=number e.g. Feature  rna; 2
                case Feature.regex(mol, num) => {
                  var feat = new Feature(mol, num.toInt)
                  ft.add(feat)
                  var k = j + 1
                  var inLoop = true

                  //add corresponding feature elements as strings e.g. Feature /name: initiation codon
                  // string "name: initiation codon" is stored
                  //System.err.println(" DEBUG+ "+mol+num+" " +lines(i))

                  while (inLoop && k < lines.length) {

                    //                    if (k >= lines.length) {
                    //
                    //                      assert(false, "Possible problem (1) in feature table." + fixed + " CHECK: " + listToString(lines))
                    //                      throw new Exception("Possible problem (1) in feature table." + fixed + " CHECK: " + listToString(lines))
                    //
                    //                    }
                    lines(k) match {

                      case FeatureElems.regex(text) => {
                        //System.err.println("-----DEBUG+" +lines(k)+ " "+text)
                        feat.add(text.trim())
                      }
                      case _ => {

                        assert(k > (j + 1))
                        //if ( lines(k).matches("") ) {
                        //System.err.println("+++++DEBUG+" +lines(k))
                        //}
                        inLoop = false
                      }
                    }
                    k += 1
                  }
                  j = k - 2
                }

                case _ => {

                  //Console.err.println("DEBUG ++ OUT "+lines(j)+" "+i+" "+j)
                  ///assert(j > (i + 10)) 10 is took from hat
                  inLoop = false
                }
              }
              j += 1
            }
            vml.add(ft)
          }

          case _ => {

            // lopp over all fields (regexs) an see do they match the line 
            fields foreach ((field) => {
              //todo: optimize... now unnecessary comparisons.. chk e.g. filter or map function

              line match {

                case field.regex(text) => {

                  if (field == Symptoms) {
                    vml.add(field, text.trim().replaceAll("Others:", ""))
                  } else {
                    vml.add(field, text.trim())
                  }

                }

                case _ => {
                  //                	if ( line.startsWith("Feat")) {
                  //                	  Console.err.println("!!!!!!  Error in line" +line )
                  //                	  assert(false)
                  //                	}
                  //                }
                }
              }

            })
          }
        }

      }
    } catch {

      case x: Exception => {
        System.err.println("CANNOT PARSE ENTRY: " + x.getMessage())
      }
    }
    return vml;
  }

  def parse(source: scala.io.Source): DataBatch = {

    var lines = List[String]()
    var batch = new DataBatch();

    source.getLines.foreach((line) => {

      line match {

        case EOR.regex() => {
          val rec: Record = handleRecord(lines.reverse) //need to reverse.. should use string buffer
          lines = List[String]()
          if (batch.header == null) {
            batch.header = rec
          } else batch.records ::= rec
        }

        case _ => {
          lines ::= line
        }
      }

    })

    return batch
  }

  def createVariant(tpe: String, name: String): Variant = {

    val v = new Variant() // need to define common methods like this
    val vn = new VariantName()
    vn.setString(name.replaceAll(";$", ""))
    vn.setScheme("HGVS")
    v.setType(tpe)
    v.setName(vn)
    return v
  }

  //sequence consequence rDNA or AA
  def createConsVariant(tpe: String, name: String): ConsVariant = {

    val v = new ConsVariant() // need to defined common methods
    val vn = new VariantName()
    vn.setString(name)
    vn.setScheme("HGVS")
    v.setType(tpe)
    v.setName(vn)
    return v
  }

  def getFeatureLines(mol: String, num: Int, ft: FeatureTable): List[String] = {
    ft.leves foreach ((l) => {
      if (l._1.equals(num) && l._2.seqType.equalsIgnoreCase(mol)) {
        return l._2.line
      }
    })
    //assert( false,"feature "+mol+" "+num+" not found. Feature table="+ft)
    //return null 
    //Console.err.println("DEBUG: 	feature " + mol.toLowerCase() + " " + num + " not found. Feature table=" + ft)
    return List()
  }

  def getFeatureProperty(prop: String, mol: String, num: Int, ft: FeatureTable): String = {
    val r = (prop + ":" + """\s+(.+)""").r
    getFeatureLines(mol, num, ft) foreach ((line) => {
      line match {
        case r(text) => {
          return text
        }
        case _ =>
      }
    })
    return null
  }

  def getAllFeatureProperty(mol: String, num: Int, ft: FeatureTable): List[(String, String)] = {
    val r = ("(\\S+):" + """\s+(.+)""").r
    var lines = List[(String, String)]()

    getFeatureLines(mol.toLowerCase(), num, ft) foreach ((line) => {
      line match {
        case r(prop, text) => {
          lines +:= (prop, text)
        }
        case _ =>
      }
    })
    return lines
  }

  def testSomeFeatureProperty(mol: String, num: Int, ft: FeatureTable) = {
    if (getAllFeatureProperty(mol, num, ft).size == 0) {
      throw new Exception("No features found for " + mol.toLowerCase() + "; " + num + " feture table=" + ft)
    }
  }

  /* get locations from feature table */
  def getLocations(mol: String, num: Int, ft: FeatureTable): List[(String, (Int, Int))] = {
    val loc = getFeatureProperty("loc", mol.toLowerCase(), num, ft)
    //assert( loc != null, "Cannot find location entry for: " +mol+" "+num)
    if (loc == null) {
      return null
    } else {
      return parseLocations(loc)
    }

  }
  def parseLocations(loc: String): List[(String, (Int, Int))] = {

    var locations = List[(String, (Int, Int))]()
    val acc = loc split """\s*;\s*"""
    val IntRange = """([\S^:]+):\s+(\d+)\.+(\d+)\s*""".r;
    val IntStart = """([\S^:]+):\s+(\d+)\s*""".r;
    val DbIntRange = """([\S^:]+):\s+([\S^:]+):\s+(\d+)\.+(\d+)\s*""".r;
    val DbIntStart = """([\S^:]+):\s+([\S^:]+):\s+(\d+)\s*""".r;
    val DbAcc = """([\S^:]+):\s*([\S^:]+)\s*""".r;

    var _start: Int = -1;
    var _end: Int = -1;
    acc.reverse foreach ((a) => {
      a match {
        case IntRange(acc, start, end) => {
          assert(_start == -1)
          _start = start.toInt
          _end = end.toInt
          locations :+= (acc, (_start, _end))
        }
        case IntStart(acc, start) => {
          assert(_start == -1)
          _start = start.toInt
          _end = start.toInt
          locations :+= (acc, (_start, _end))

        }
        case DbIntRange(db, acc, start, end) => {
          assert(_start == -1)
          _start = start.toInt
          _end = end.toInt
          locations :+= (db + ":" + acc, (_start, _end))

        }
        case DbIntStart(db, acc, start) => {
          assert(_start == -1)
          _start = start.toInt
          _end = start.toInt
          locations :+= (db + ":" + acc, (_start, _end))
        }
        case DbAcc(db, acc) => {
          //assert(_start > -1," problems in location "+a+" " )
          val test = """.*\s+(\d+)$""".r
          val test2 = """.*\s+(\d+)\.\.(\d+)$""".r
          val test3 = """.*\s+(\d+)-(\d+)$""".r
          loc match {
            case test(pos) => {
              locations :+= (db + ":" + acc, (pos.toInt, pos.toInt))
            }
            case test2(pos1, pos2) => {
              locations :+= (db + ":" + acc, (pos1.toInt, pos2.toInt))
            }
            case test3(pos1, pos2) => {
              locations :+= (db + ":" + acc, (pos1.toInt, pos2.toInt))
            }
            case _ => {
              Console.err.println("Coordinates are missing in location entry: " + a + " line: " + loc)
            }
          }
        }
        case _ => {
          Console.err.println("Unknown entry " + a + " line: " + loc)
          //assert(false, "unknown location entry: " + a)
        }

      }
    })
    return locations
  }

  //parse systematic name. Return list of HGVS names or null if not OK
  def parseSysName(text: String): Array[String] = {

    var txt = text.replaceAll("\\s+", " ").replace("\\s$", "").replace(",", "")
    txt = txt.replace("[", "]") // let's make life bit easier
    val names = txt.split("""\s+(?=([^\]]*\][^\]]*\])*[^\]]*$)""") filter ((v) => v.length() > 0)
    assert(names.length != 0, " Unknown sys name " + text)
    var error = false
    var newNames = List[String]()
    var gt = """([gcrp])\.\]([^\]]+)\]""".r
    var gt2 = """\]([^\]]+)\]""".r
    var gt3 = """([gcrp]\..*)""".r
    names foreach ((n) => {

      n match {

        case gt(x, v) => {
          var t = v split "\\s*;\\s*"
          t foreach ((name) => {
            if (name.matches("^[gcrp]\\..*")) {
              newNames +:= name
            } else {
              if (name.matches("[gcrp]\\..*")) {

                newNames +:= name
                assert(name.startsWith(x))
              } else {

                newNames +:= (x + "." + name)
              }
            }
          })

        }
        case gt2(v) => {

          var t = v split "\\s*;\\s*"
          t foreach ((name) => {
            if (name.matches("^[gcrp]\\.\\S+")) {
              newNames +:= name
            } else {
              //assert(false, "check name " + name)
              error = true
            }
          })

        }

        case gt3(name) => {
          newNames +:= name
        }
        case _ => {
          error = true
          //newNames +:= n
        }

      }

    })

    newNames foreach ((c) => {
      assert(c.indexOf("]") == -1 && c.indexOf("[") == -1, "check name " + c)
    })

    if (error) {
      return null //error case todo: throw exception?
    } else {
      return newNames.toArray[String]
    }

  }

  //todo: merge createVariant and creteConsVariant methods
  def createVariant(typeAttr: String, name: String, counter: Int, ft: FeatureTable): VmlVariantObservation = {
    val v = {
      if (typeAttr.equals("DNA")) { new Variant() }
      else { new ConsVariant() }
    }

    val n = new VariantName(name)
    n.setScheme("HGVS")
    v.setName(n)
    //v.setType(typeAttr)
    if (typeAttr.equalsIgnoreCase("dna") ||
      typeAttr.equalsIgnoreCase("rna") ||
      typeAttr.equalsIgnoreCase("aa")) {
      val locs = getAllFeatureProperty(typeAttr, counter, ft)
      if (locs.size == 0) {
        throw new Exception("feature table probably not OK or counter is out of sync.. No entries found for: " + typeAttr.toLowerCase() + " " + counter + "; Feature table=" + ft)
      }
    }
    return v
  }

  def createComment(term: String, text: String): Comment = {
    val com = new Comment()
    val _text = new CommentText()
    com.setTerm(term)
    _text.setString(text)
    com.addText(_text)
    return com
  }
  def getSeqChanges(variant: VmlVariantObservation): SeqChanges = {

    if (variant.getSeqChanges() == null) {
      variant.setSeqChanges(new SeqChanges())
    }
    return variant.getSeqChanges()
  }
  def getAliases(variant: VmlVariantObservation): Aliases = {

    if (variant.getAliases() == null) {
      variant.setAliases(new Aliases())
    }
    return variant.getAliases()
  }

  def createEventInstance(variant: Variant): VariantEvent = {
    val e = new VariantEvent()
    e.setLocationList(variant.getLocationList())
    e.setVariantClassList(variant.getVariantClassList())
    e.setSeqRegionList(variant.getSeqRegionList())
    e.setVariantTypeList(variant.getVariantTypeList())
    e.setCommentList(variant.getCommentList())
    e.setName(variant.getName)
    e.setSeqChanges(variant.getSeqChanges())
    e.setAliases(variant.getAliases())
    e.setConsequenceList(variant.getConsequenceList())
    return e
  }

  def annotate(variant: VmlSimpleVariantEvent, featureLines: List[(String, String)]) = {
    if (featureLines.size == 0) {
      //throw new Exception("NO features for variant " + variant.getType())
    }
    // remeber to update create VariantEvent instance method
    featureLines foreach ((line) => {

      variant.addComment(createComment(line._1, line._2))
      line._1 match {

        case "genomic_region" => {
          assert(variant.isInstanceOf[Variant])
          val loc = "\\s*([a-zA-Z]+)\\s*;\\s*(\\d+)\\s*".r
          val reg_type = new SeqRegion()
          line._2 match {
            case loc(name, pos) => {
              reg_type.setTerm(name)
              val loc = new Location()
              loc.setUnit("feature")
              loc.setStart(Integer.parseInt(pos))
              reg_type.addLocation(loc)
            }
            case _ => {
              reg_type.setTerm("unknown")
              reg_type.addComment(createComment(line._1, line._2))
            }
          }
          variant.addSeqRegion(reg_type)
        }

        case "name" => {
          //name of variant point.. missense .. out out of frame..
          val loc = "\\s*(\\S+.*)\\s*".r

          if (variant.isInstanceOf[ConsVariant]) {
            val anno = new Consequence()
            line._2 match {
              case loc(name) => {
                anno.setTerm(name)
              }
              case _ => {
                anno.setTerm("unknown")
                anno.addComment(createComment(line._1, line._2))
              }
            }
            variant.addConsequence(anno)

          } else {

            //Genomic mutation "names" are often considered as variant types 
            val anno = new VariantType()
            line._2 match {
              case loc(name) => {
                anno.setTerm(name)
              }
              case _ => {
                anno.setTerm("unknown")
                anno.addComment(createComment(line._1, line._2))
              }
            }
            variant.addVariantType(anno)

          }
        }

        case "loc" => {
          val locs = parseLocations(line._2)
          locs foreach ((l) => {
            val refAsDbXref = new RefSeq()
            val refAsList = l._1 split (":")

            if (refAsList.size > 1) {

              refAsDbXref.setAccession(refAsList(1))
              refAsDbXref.setSource(refAsList(0))

            } else {

              refAsDbXref.setAccession(l._1)

            }

            //we use this also as a reference sequence 
            //which is used to give systematic name
            if (variant.getRefSeq() == null) {
              variant.setRefSeq(refAsDbXref) //todo: chekc is this ok . at least position should with systematic name
            }
            if (l._2._1 > 0 && l._2._2 > 0) {
              val _loc = new Location()
              _loc.setRefSeq(refAsDbXref)
              _loc.setStart(l._2._1)
              _loc.setEnd(l._2._2)
              variant.addLocation(_loc)
            }
          })
        }

        //TODO: handle other annotations
        case _ => {
          //Console.err.println(line._1)
        }

      }

    })

    //}
  }

  //dig out genomic variants and corresponding sequence consequences (resulting RNAs and AAs) with their feature details
  def getGenomicVariants(sysNames: Array[String], ft: FeatureTable, counterStart: Int): (List[Variant], Int) = {

    assert(counterStart >= 0, "counter " + counterStart)
    assert(sysNames.length > 0)

    val Dna = """^g\..*""".r
    val cDna = """^c\..*""".r
    val rDna = """^r\..*""".r
    val AA = """^p\..*""".r

    var variantList: List[Variant] = List[Variant]()
    var cDNAvariantList: List[Variant] = List[Variant]()
    var RNAvariantList: List[ConsVariant] = List[ConsVariant]()
    var AAvariantList: List[ConsVariant] = List[ConsVariant]()

    var isFeatureTableOK = true

    //testing
    var rnaMissing = true

    sysNames foreach ((s) => {

      val name = new VariantName(s)
      name.setScheme("HGVS")
      s match {

        case Dna() => {

          val v = createVariant("DNA", s)
          variantList :+= v

        }

        case cDna() => {

          val v = createVariant("cDNA", s)
          cDNAvariantList :+= v

        }

        case rDna() => {

          val v = createConsVariant("RNA", s)
          RNAvariantList :+= v

        }

        case AA() => {

          val v = createConsVariant("AA", s)
          AAvariantList :+= v

        }

        case _ => {
          sysNames foreach ((name) => { println(name) })
          assert(false, "Unknown name=" + s)

        }
      }
    })

    var counter = counterStart //counter used to get feature table entries like Feature  dna; 1

    if (variantList.length > 0 && cDNAvariantList.length > 0) {
      var ix = 0;
      variantList foreach (l => {
        //println(l.getName().getString())

        if (cDNAvariantList.length > ix) getAliases(l).addVariant(cDNAvariantList(ix))
        ix = ix + 1
      })
    }
    //    if (cDNAvariantList.length > 0) {
    //      cDNAvariantList foreach (l => println(l.getName().getString()))
    //    }
    //we need to figure how DNA, RNA ja AA sequence are related
    if (variantList.length == RNAvariantList.length &&
      variantList.length == AAvariantList.length) {

      // no problem with this..
      //val chk = getSomeFeatureProperty(typeAttr, counter, ft)

      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        val rna = RNAvariantList(i)
        val aa = AAvariantList(i)
        counter += 1
        val dnaFT = getAllFeatureProperty("DNA", counter, ft)
        val rnaFT = getAllFeatureProperty("RNA", variantList.length + counter, ft)
        val aaFT = getAllFeatureProperty("AA", variantList.length * 2 + counter, ft)
        getSeqChanges(dna).addVariant(rna)
        getSeqChanges(rna).addVariant(aa)
        annotate(dna, dnaFT)
        annotate(rna, rnaFT)
        annotate(aa, aaFT)
      }
      counter = variantList.length * 3;

    } else if (RNAvariantList.length == 0 && // no RNAs in systematicName field
      variantList.length == AAvariantList.length) {

      // we could create dummy RNAss but not done right now
      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        //val rna = RNAvariantList(i)
        val aa = AAvariantList(i)
        counter += 1
        val dnaFT = getAllFeatureProperty("DNA", counter, ft)
        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft) // we should have feature table data for RNAs there anyway
        val aaFT = getAllFeatureProperty("AA", variantList.length * 2 + counter, ft)
        getSeqChanges(dna).addVariant(aa) // AA added directly into DNA variant
        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)
        annotate(dna, dnaFT)
        //annotate(rna.asInstanceOf[MyVariant],rnaFT)
        annotate(aa, aaFT)

      }
      counter = variantList.length * 3; // we need to increment like this

    } else if (variantList.length == RNAvariantList.length &&
      AAvariantList.length == 0) {

      // we could create dummy AAs but not done right now
      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        val rna = RNAvariantList(i)
        //val aa = AAvariantList(i)
        counter += 1
        val dnaFT = getAllFeatureProperty("DNA", counter, ft)
        val rnaFT = getAllFeatureProperty("RNA", variantList.length + counter, ft)
        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft) // aa data should be there still??...check
        getSeqChanges(dna).addVariant(rna)
        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)
        annotate(dna, dnaFT)
        annotate(rna, rnaFT)
        //annotate(aa.asInstanceOf[MyVariant],aaFT)

      }
      counter = variantList.length * 3; // we need to increment like this      

    } else if (variantList.length > 0 &&
      RNAvariantList.length == 0 && AAvariantList.length == 0) {

      // we could create dummy AA and RNAss but not done right now
      for (i <- 0 until variantList.length) {

        val dna = variantList(i)
        //val rna = RNAvariantList(i)
        //val aa = AAvariantList(i)
        counter += 1
        val dnaFT = getAllFeatureProperty("DNA", counter, ft)
        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft) // rna data should be there still ...
        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft) // aa data should be there still??...check
        //getSeqChanges(dna.asInstanceOf[MyVariant]).addVariant(rna)
        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)
        annotate(dna, dnaFT)
        //annotate(rna.asInstanceOf[MyVariant],rnaFT)
        //annotate(aa.asInstanceOf[MyVariant],aaFT)

      }
      counter = variantList.length * 3; // we need to increment like this      

    } else if (variantList.length == 0 && // we have only proteins..
      RNAvariantList.length == 0 && AAvariantList.length > 0) {

      throw new Exception("We have only amino acid.. check how to handle");

      //      for (i <- 0 until AAvariantList.length) {
      //
      //        //val rna = RNAvariantList(i)
      //        //val aa = AAvariantList(i)
      //        counter += 1
      //        val dnaFT = getAllFeatureProperty("DNA", counter, ft)
      //        val rnaFT = testSomeFeatureProperty("RNA", variantList.length + counter, ft) // rna data should be there still ...
      //        val aaFT = testSomeFeatureProperty("AA", variantList.length * 2 + counter, ft) // aa data should be there still??...check
      //        //getSeqChanges(dna.asInstanceOf[MyVariant]).addVariant(rna)
      //        //getSeqChanges(rna.asInstanceOf[MyVariant]).addVariant(aa)
      //        annotate(dna.asInstanceOf[MyVariant], dnaFT)
      //        //annotate(rna.asInstanceOf[MyVariant],rnaFT)
      //        //annotate(aa.asInstanceOf[MyVariant],aaFT)
      //
      //        //
      //        variantList +:= createVariant("AA", AAvariantList(i).getName().getString())
      //
      //      }
      counter = AAvariantList.length * 3; // we need to increment like this      

    } else {

      throw new Exception("Do not undestand how systematic names are grouped.. i.e. how DNA - RNA - AA are related and how they match feature table entries")

    }
    if (cDNAvariantList.length != RNAvariantList.length && RNAvariantList.length > 0) {
      if (variantList.length > 0) {
        Console.err.println("Check " + variantList(0).getName().getString() + " ")
      }
    }
    //    for( i <- 0 to cDNAvariantList.length ) {
    //      cDNAvariantList(i).setRefSeq( RNAvariantList(i).getRefSeq()) // same ref seq used
    //    }
    return (variantList, counter)
  }

  def getCommonReferenceSequenceNameFromListOfVariants(v: List[Variant]): RefSeq = {
    var t: RefSeq = null;

    v foreach ((x) => {
      if (t == null)
        t = x.getRefSeq
      else {
        if (!x.getRefSeq.getAccession().equals(t.getAccession)) { //todo chk source field
          //throw new Exception("Reference sequence differ in varian list: " + x.getRefSeq.getAccession + " " + t.getAccession)
          Console.err.println("Reference sequence differ in varian list: " + x.getRefSeq.getAccession + " " + t.getAccession)
          //t == x.getR
        }
      }
    })
    if (t == null) {
      t = new RefSeq()
      t.setSource("IDBASE")
      t.setAccession("UNKNOWN")
    }
    return t

  }
  def toXML(batch: DataBatch): Lsdb = {

    val hOut  = new java.io.PrintWriter(new File("test.tab"))
    hOut.println("")
    
    val lsdb = new Lsdb()
    val source = new org.varioml.jaxb.Source()
    val contact = new Contact()
    contact.setName(batch.getHeader(Curator))
    contact.setAddress(batch.getHeader(Address))
    source.setName(batch.getHeader(Database))
    source.addContact(contact)
    var ack = new Acknowledgement()
    ack.setName(batch.getHeader(Funding))
    source.addAcknowledgement(ack)
    lsdb.addSource(source)
    var counter = 0
    var failed = 0
    var noSystematicName = 0

    val patho = new Pathogenicity()
    patho.setTerm("Likely pathogenic")
    patho.setSource("cmgs_vgl_5")
    patho.setAccession("p_0003")
    val pheno = new Phenotype()
    pheno.setTerm(batch.getHeader(Disease))
    //NOTE THIS IS FENOTYPE TESTED.. we put that into panel
    if (batch.getHeader(OMIM) != null) {
      pheno.setAccession(batch.getHeader(OMIM))
      pheno.setSource("OMIM")
    }
    patho.addPhenotype(pheno)

    batch.records foreach ((rec) => {

      try {

        counter += 1
        val inv = new Individual()
        val sexStr = rec.get(Sex)
        val gender = new Gender()

        
        if (sexStr != null) {
          if (sexStr.equals("XX")) {
            gender.setCode(2)
          } else if (sexStr.equals("XY")) {
            gender.setCode(1)
          } else {
            gender.setCode(9)
            val desc = new GenderDescription()
            desc.setTerm(sexStr)
            desc.setSource("idbase")

          }
          inv.setGender(gender)

        }

        //val panel = new Panel()
        //panel.addIndividual(inv)
        inv.setId(rec.get(Accession))
        val symptoms = rec.get(Symptoms)
        if (symptoms != null) {

          symptoms.split(";") foreach ((s) => {
            //symptoms are stored as phenotypes of individual  
            val symptom = new Phenotype()
            symptom.setTerm(s.trim())
            symptom.setDescription("Symptom")
            symptom.setType("symptom")
            inv.addPhenotype(symptom)

          })

          val diagnosis = rec.get(Diagnosis)
          if (diagnosis != null) {
            val pheno = new Phenotype()
            pheno.setTerm(diagnosis)
            pheno.setType("diagnose")
            inv.addPhenotype(pheno)

          }


        }

          val pop = rec.get(EthnicOrigin)
          if (pop != null) {
            val population = new Population()
            population.setTerm(pop)
            population.setTerm(pop)
            population.setType("ethnic")
            inv.addPopulation(population)
          }

        val sysName = rec.get(SystematicName)
        //get systematic names and try to find corresonding feature table entry
        // like: Feature         dna; 1
        if (sysName == null) {

          noSystematicName += 1
          Console.err.println("NO SYS NAME: " + inv.getId())

        } else {

          var allelesStr: String = null
          //handle different sname entries
          val case1 = "Allele\\s+1\\s+and\\s+Allele\\s+2:?\\s+(\\S+.*)".r
          val case2 = "Allele\\s+1\\s+and\\s+2:?\\s+(\\S+.*)".r
          val case3 = "Allele\\s+1:?\\s+(\\S+.*)".r
          val case4 = "\\s*(\\S+.*)".r

          var homozygVariant = false
          var genotypeVariant = false
          val EMPTY_ARRAY = Array[String]()

          var systematicNames = (EMPTY_ARRAY, EMPTY_ARRAY)

          sysName match {
            case case1(text) => {

              val names = parseSysName(text)
              systematicNames = (names, names)
              homozygVariant = true
            }
            case case2(text) => {

              val names = parseSysName(text)
              systematicNames = (names, names)
              homozygVariant = true
            }
            case case3(_text) => {

              var text = _text.replaceAll("Allele 1:?", "") // we may have other Allele 1s there see adabase.dat A0057
              if (text.indexOf("Allele 2") > -1) {

                val texts = text split "Allele 2:?"
                if (texts.length != 2) {
                  throw new Exception("Systematic name is not as it should be: " + _text)
                }

                val names1 = parseSysName(texts.head)
                val names2 = parseSysName(texts.tail.head)
                systematicNames = (names1, names2)
                genotypeVariant = true

              } else {

                val names = parseSysName(text)
                systematicNames = (names, names)
                homozygVariant = false

              }
            }
            case case4(text) => {

              if (text.indexOf("Allele") > -1) {

                throw new Exception("Unknown systematic name " + sysName + " " + inv.getId())
              }
              val names = parseSysName(text)
              systematicNames = (names, names)
              homozygVariant = false
            }

            case _ => {

              Console.err.println("UNKNOWN : " + inv.getId())

              throw new Exception("Unknown systematic name " + sysName + " " + inv.getId())
            }
          }

          val vari = {

            if (systematicNames._1 != null && systematicNames._2 != null) {

              try {

                val thisVariant = new Variant()

                val hap1 = new Haplotype()
                val (v1, c) = getGenomicVariants(systematicNames._1, rec.getFt("1"), 0)
                v1 foreach ((va) => {
                  hap1.addVariant(createEventInstance(va))
                })
                hap1.setAllele(1)
                thisVariant.addHaplotype(hap1)
                val refSeq = getCommonReferenceSequenceNameFromListOfVariants(v1)
                if (genotypeVariant) {

                  val (v2, c2) = getGenomicVariants(systematicNames._2, rec.getFt("2"), c)
                  if (!getCommonReferenceSequenceNameFromListOfVariants(v2).getAccession().equals(refSeq.getAccession)) {
                    //throw new Exception("We have different reference sequences in allele 1 and allele 2 : >"+
                    //getCommonReferenceSequenceNameFromListOfVariants(v2).getAccession()+"< >"+refSeq.getAccession()+"<")
                    Console.err.println("We have different reference sequences in allele 1 and allele 2 : >" +
                      getCommonReferenceSequenceNameFromListOfVariants(v2).getAccession() + "< >" + refSeq.getAccession() + "<")

                  }
                  val hap2 = new Haplotype()
                  hap2.setAllele(2)

                  v2 foreach ((va) => {
                    hap2.addVariant(createEventInstance(va))
                  })

                  if (v1.size > 1 && v2.size > 1) {
                    Console.err.println("** ++++++++++* Check case: " + inv.getId())
                  }

                  thisVariant.addHaplotype(hap2)

                  if (hap1.getVariantList() == null || hap1.getVariantList().size() == 0) {
                    Console.err.println(" CHECK PATIENT.. Hap1 =" + inv.getId())
                  }
                  if (hap2.getVariantList() == null || hap2.getVariantList().size() == 0) {
                    Console.err.println(" CHECK PATIENT.. Hap2 =" + inv.getId())
                  }
                } else if (homozygVariant) {

                  //dipoid
                  val hap2 = new Haplotype()
                  v1 foreach ((va) => {
                    hap2.addVariant(createEventInstance(va))

                  })
                  hap2.setAllele(2)
                  thisVariant.addHaplotype(hap2)
                  val c = new Comment()
                  c.addText(new CommentText("same as allele 1"))
                  hap2.addComment(c)
                }

                thisVariant.setGenotypic(true)
                thisVariant.setRefSeq(refSeq)
                thisVariant

              } catch {

                //todo: move exception handling out
                case x: java.lang.IndexOutOfBoundsException => {
                  //x.printStackTrace()
                  throw new Exception(" CHECK PATIENT=" + inv.getId() + " " + x.getMessage() + " " + x)
                }
                case x: Exception => {
                  //x.printStackTrace();	
                  throw new Exception(" CHECK PATIENT=" + inv.getId() + " " + x.getMessage() + " " + x)
                }

              }

            } else {

              throw new Exception(" CHECK PATIENT=" + inv.getId() + ". Cannot parse systematic name: " + sysName)

            }

          }

          vari.addPathogenicity(patho)
          inv.addVariant(vari)
          //vari.addPanel(panel)
          val dec = new Comment()
          dec.setTerm("description")
          val cons = new Consequence()
          cons.setTerm(rec.get(Description))
          vari.addConsequence(cons)
          val gene = new Gene()
          gene.setSource("HUGO")
          gene.setAccession(batch.getHeader(Gene))
          vari.setGene(gene)
          lsdb.addIndividual(inv)
          
          var ix = 7
          systematicNames._1.sorted.foreach ((n)=>{
            ix = ix - 1
            assert(ix>0)
            hOut.print(n.replaceAll("\\s*;\\s*$","").trim()+"\t")
          })
          for( i <- ix to 0 by  -1) {
            hOut.print("\t")
          }
          ix = 7
          systematicNames._2.sorted.foreach ((n)=>{
            ix = ix - 1
            assert(ix>0)
            hOut.print(n.replaceAll("\\s*;\\s*$","").trim()+"\t")
          })
          for( i <- ix to 0 by  -1) {
            hOut.print("\t")
          }
          
          hOut.println(rec.get(Accession)+"\t"+sexStr+"\t"+rec.get(Diagnosis)+
              "\t"+rec.get(EthnicOrigin)+"\t"+rec.get(Relative)+"\t"+rec.get(RefCrossRef)+
              "\t"+rec.get(RefAuthors)+"\t"+rec.get(RefTitle))

        }

      } catch {

        case x: Exception => {

          x.printStackTrace();
          System.err.println(x.getMessage())
          failed += 1
        }

      }

    }) // looping over records

    println("Individuals " + counter + " ft failed =" + failed + " no systematic name=" + noSystematicName)

    return lsdb
  }

  def processFile(directory: String, file: java.io.File) = {

    val s = scala.io.Source.fromFile(file, "UTF-8")
    val batch = parse(s)
    val SEP = java.io.File.separatorChar
    val dir = new java.io.File(directory)
    if (!dir.exists()) {

      dir.mkdir()

    } else {

      assert(dir.isDirectory(), directory + " is not directory. remove the file")
    }

    batch.header.propertyMap foreach ((tuple) => {
      //println(tuple._1 + " Value= " + tuple._2)
    })
    batch.records.foreach((rec) => {
      rec.featureTables foreach ((ft) => {
        //println(ft)
      })
    })

    val lsdb = toXML(batch)
    val util = new Util()
    //util.writeXML("schema/lsdb.xsd", directory + SEP + file.getName() + ".xml", lsdb)
    //util.writeXML( directory + SEP + file.getName() + ".xml", lsdb)
    //util.writeXML(directory + SEP + file.getName() + ".xml",lsdb)
    //util.writeJSON(directory + SEP + file.getName() + ".json", lsdb)
    writeTab(lsdb)
  }

  def printToFile(f: java.io.File)(op: java.io.PrintWriter => Unit) {
    val p = new java.io.PrintWriter(f)
    try { op(p) } finally { p.close() }
  }
  def writeTab(lsdb: Lsdb) = {

    var map = scala.collection.mutable.HashMap[String, List[Individual]]()

    printToFile(new File("idbase.tab"))(prt => {
      lsdb.getIndividualList() foreach (l => {
        l.getVariantList() foreach (v => {
          v.getHaplotypeList() foreach (h => {
            if (h.getVariantList() == null) {
              Console.err.println("empty: " + l.getId() + " ")
              val ali = h.getAliases()
              if (ali != null) {
                ali.getVariantList() foreach (a => {
                  Console.err.println(a.getName().getString())
                })
              }
            } else {

              h.getVariantList() foreach (a => {
                val ali = a.getAliases()
                if (ali == null) {
                  Console.err.println("cgheck: " + l.getId())
                } else {
                  assert(ali.getVariantList().size() == 1, " not supported...")
                  val a = ali.getVariantList()(0)
                  if (map.contains(a.getName().getString())) {
                    map.put(a.getName().getString(),
                      map.get(a.getName().getString()).get ::: List(l))
                  } else {
                    map.put(a.getName().getString(), List(l))
                  }
                }
              })
            }
          })
        })
      })

      val cMap = HashMap("Norway" -> "Norwegian","Finland"->"Finnish",
        "Slovenia" -> "Slovenian", "Russia" -> "Russian", "Italy" -> "Italian",
        "Hungary" -> "Hungarian", "Egypt" -> "Egyptian", "USA" -> "American", "Korea" -> "Korean",
        "Japan" -> "Japanise", "Sicily" -> "Sicilian", "India" -> "Indian",
        "Britain" -> "British", "Poland" -> "Polish", "Allele 1:Korea; Allele 2:Japan" -> "Korean/Japanise")

      prt.println("mutation\thomozyg\tpopulation\tcombined\tgenome\tRNA\tAA\tdisease")
      map.keySet foreach (k => {
        prt.print(k + "\t")

        val indivs = map.get(k).get
        val distincts = indivs.distinct
        val homo = indivs.size - distincts.size
        val pops1 = (distincts flatMap ((i: Individual) => {
          val popList = i.getPopulationList()
          if (popList != null) {
            i.getPopulationList().map(_.getTerm().replaceAll("Mongoloid\\s*;\\s*", "")
              .replaceAll("Caucasoid\\s*;\\s*", ""))
          } else {
            ""
          }
        })).distinct


         val disease = (distincts flatMap ((i: Individual) => {
          val phenoList = i.getPhenotypeList()
          if (phenoList != null) {
            phenoList.filter(_.getType() == "diagnose").map(_.getTerm())
          } else {
            ""
          }
        })).distinct

        val pops = pops1.map(p => if (cMap.get(p) != null) { cMap.get(p) } else { p })
        prt.print(homo + "\t" + (indivs.size - homo) + "\t" + pops.mkString(";")+"\t")

        var test = List[VmlVariantEvent]()
        distincts foreach (l => {
          l.getVariantList() foreach ((v) => {
            v.getHaplotypeList() foreach ((h) => {
              if (h.getVariantList() != null) {
                h.getVariantList() foreach ((v) => {
                  assert(v.getAliases().getVariantList().size() == 1)
                  val x = v.getAliases().getVariantList().get(0)
                  if (x.getName().getString() == k) {
                    test = test ::: List(v)
                  }
                })
              } else {
                Console.err.println("CHEK " + l.getId())
              }
            })
          })
          
          assert(test.size > 0, " Alias mismatch " + k + " " + test.size)
          val head = test.head
          val tail = test.tail
          if (head.getSeqChanges() != null && head.getSeqChanges().getVariantList() != null) {
            val sq1 = head.getSeqChanges().getVariantList().get(0)
            tail foreach ((x) => {
              if (head.getName().getString() != x.getName().getString()) {
                Console.err.println("ERROR " + head.getName() + " " + x.getName().getString)
              }
              val sq = x.getSeqChanges()
              val sq2 = x.getSeqChanges().getVariantList().get(0)
              if (sq2.getName().getString() != sq1.getName().getString()) {
                Console.err.println("ERROR " + head.getName() + " " + x.getName().getString)
              }

            })
          } else {
            Console.err.println("CHK HIS " + l.getId())
          }
        })
        val ge = test.head.getName().getString()
        val sq1 = test.head.getSeqChanges()
        var rna=""
        var aa = ""
        if ( sq1 != null  && sq1.getVariantList() != null) {
          rna = sq1.getVariantList().get(0).getName().getString()
          val sq2 = sq1.getVariantList().get(0).getSeqChanges()
          if ( sq2 != null  && sq2.getVariantList() != null) {
        	  aa = sq2.getVariantList().get(0).getName().getString()            
          }
        }
        if ( rna.startsWith("p.")) {
          assert(aa.isEmpty(),"check name "+rna)
        	prt.print(ge+"\t"+""+"\t"+rna+"\t"+disease.mkString(";"))          
        } else {
        	prt.print(ge+"\t"+rna+"\t"+aa+"\t"+disease.mkString(";"))          
        }
        prt.println()
      })
    })

  }

  def main(args: Array[String]) {
    assert(args.length > 0)

    val file = args(0);
    println("File: " + file)

    val f = new java.io.File(file)
    if (f.isDirectory()) {

      val files = f.listFiles()
      (files filter (f => """.*\.dat$""".r.findFirstIn(f.getName).isDefined)) foreach ((_file) => {
        if (_file != null && _file.canRead()) {

          Console.err.println("======= Reading " + _file.getPath())
          processFile("idbase_xml", _file)

        } else {

          Console.err.println("Cannot read file " + _file.getPath())
        }
      })

    } else {

      processFile("idbase_xml", new java.io.File(file))

    }

  }
}